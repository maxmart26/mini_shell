void	init_minishell(t_data *tools, char **env)
{
	tools->envp = env;
	if (tools->envp[0] == NULL)
		tools->env = init_env_i();
	else
	{
		tools->env = init_env(tools, 0);
		init_env_shlvl(tools->env, tools);
	}
	init_path(tools);
	tools->status = 1;
	tools->exit_status = 0;
	g_status = 1;
	tools->first_call = 1;
	show_ctrl(1);
	signal(SIGQUIT, &ft_signal_handler);
	handle_signal();
}

int	minishell(t_data *tools, char **env)
{
	char	*str;

	init_minishell(tools, env);
	while (g_status)
	{
		str = show_prompt(tools);
		tools->args = readline(str);
		free(str);
		if (!tools->args)
			ctrl_d(tools);
		check_new_line(tools);
		if (tools->nl_error == 0 || tools->nl_error == 2)
		{
			add_history(tools->args);
			if (tools->nl_error == 0)
			{
				lexer_and_parser(tools);
				init_data(tools->lexer_list, tools);
				if (g_status != 258)
					ft_main(tools);
			}
		}
		free(tools->args);
	}
	free_minishell(tools);
	return (EXIT_SUCCESS);
}

int	main(int ac, char **argv, char **env)
{
	t_data	*tools;

	(void)argv;
	tools = malloc(sizeof(t_data));
	if (!tools)
		return (free(tools), EXIT_FAILURE);
	if (ac != 1)
	{
		printf("No arguments accepted.\n");
		free(tools);
		exit(0);
	}
	minishell(tools, env);
	return (0);
}

void	ctrl_d(t_data *tools)
{
	printf("exit\n");
	ft_exit(tools, 1);
}

void	ft_exit(t_data *data, int i)
{
	(void)data;
	if (i == 0)
		exit(158);
	else
	{
		free_minishell_ctrld(data);
		exit(1);
	}
}
void	free_minishell_ctrld(t_data *tools)
{
	free(tools->args);
	free(tools);
}

void	init_env_shlvl(t_env *env, t_data *data)
{
	int		a;
	char	*str;
	char	*tmp;
	char	**token;

	if (!env)
	{
		ft_destroy_env(env);
		return ;
	}
	while (env)
	{
		if (ft_strncmp(env->name, "SHLVL", 6) == 0)
		{
			a = ft_atoi(env->content);
			if (a < 0)
				return ;
			a++;
			tmp = ft_itoa(a);
			str = ft_strjoin("SHLVL=", tmp);
			free(tmp);
			token = token_init("export", str);
			ft_export(token, data, -1);
			free(str);
			//ft_free_tab(token);
		}
		env = env->next;
	}
}

void	ft_export_2(char **strs, t_data *data)
{
	char	*name;
	char	**str;
	char	*content;
	t_env	*current;

	str = ft_split(strs[1], '=');
	if (str && str[0] && str[1] && ft_expor_ex(strs[1], data, str) == 1)
	{
		name = strdup(str[0]);
		content = strdup(str[1]);
		if (!data->env)
		{
			data->env = new_env();
			data->env->value = ft_strdup(strs[1]);
			data->env->content = content;
			data->env->name = name;
		}
		else
		{
			current = data->env;
			while (current->next)
				current = current->next;
			current->next = new_env();
			if (!current->next)
			{
				free(name);
				free(content);
				return ;
			}
			current->next->value = ft_strdup(strs[1]);
			current->next->prev = current;
			current->next->content = content;
			current->next->name = name;
			while (data->env->prev)
				data->env = data->env->prev;
		}
	}
	if (str)
		ft_free_tab(str);
}

void	ft_export(char **strs, t_data *data, int i)
{
	if (i == 0)
		exit(156);
	if (strs[1] == NULL)
		ft_trie_export(data);
	else
	{
		ft_export_2(strs, data);
	}
}

void	ft_free_tab(char **input)
{
	size_t	i;

	i = 0;
	while (input[i])
	{
		free(input[i]);
		i++;
	}
	free(input);
}

static void	set_mem(char **dest, char const *s, char c)
{
	size_t	count;
	size_t	index;
	size_t	i;

	index = 0;
	i = 0;
	while (s[index])
	{
		count = 0;
		while (s[index + count] && s[index + count] != c)
			count++;
		if (count > 0)
		{
			dest[i] = malloc(sizeof(char) * (count + 1));
			if (!dest[i])
			{
				while (i > 0)
					free(dest[--i]);
				free(dest);
				return ;
			}
			fill_tab(dest[i], (s + index), c);
			i++;
			index += count;
		}
		else
			index++;
	}
	dest[i] = NULL;
}

char	**ft_split(char const *s, char c)
{
	char	**dest;
	size_t	words;

	words = count_words(c, (char *)s);
	dest = (char **)malloc((words + 2) * sizeof(char *));
	if (!dest)
		return (NULL);
	set_mem(dest, s, c);
	return (dest);
}
